<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>4 en Raya - AdriPM-APM</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #232946;
            color: #f4f4f4;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header-info {
            background: rgba(0,0,0,0.2);
            padding: 8px 16px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            color: #eebbc3;
        }

        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 24px 16px 32px 16px;
            background: #22223b;
            border-radius: 12px;
            box-shadow: 0 2px 24px rgba(0,0,0,0.3);
            text-align: center;
            flex: 1;
        }

        h1 {
            margin-bottom: 8px;
            color: #eebbc3;
            text-shadow: 0 1px 6px #16161a44;
            font-size: 2rem;
        }

        .controls {
            margin: 20px 0 12px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 14px;
            flex-wrap: wrap;
        }

        .controls label {
            font-size: 1rem;
        }

        select {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            background: #2f2f4d;
            color: #f4f4f4;
            cursor: pointer;
        }

        #restartBtn {
            background: #eebbc3;
            color: #232946;
            border: none;
            border-radius: 6px;
            padding: 8px 18px;
            font-size: 1rem;
            cursor: pointer;
            margin-left: 12px;
            transition: all 0.2s;
        }

        #restartBtn:hover {
            background: #ffd6e0;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #restartBtn:active {
            transform: translateY(0);
        }

        #turnIndicator {
            margin-bottom: 16px;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        #currentPlayer {
            font-weight: bold;
            color: #ff595e;
            transition: color 0.3s;
        }

        #gameContainer {
            display: flex;
            justify-content: center;
            margin-bottom: 16px;
            width: 100%;
            touch-action: manipulation;
        }

        #gameBoard {
            background: #21209c;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            max-width: 700px;
            height: auto;
            aspect-ratio: 7 / 6;
            display: block;
        }

        #gameBoard:hover {
            box-shadow: 0 6px 24px rgba(0,0,0,0.4);
        }

        #message {
            min-height: 24px;
            font-size: 1.15rem;
            font-weight: 500;
            color: #eebbc3;
            margin-top: 10px;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        #message:not(:empty) {
            background-color: rgba(0,0,0,0.2);
        }

        @media (max-width: 760px) {
            .container {
                margin: 10px auto;
                padding: 16px 8px;
            }

            .header-info {
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 4px;
            }

            #gameBoard {
                max-width: 96vw;
            }

            h1 {
                font-size: 1.5rem;
            }

            .controls {
                gap: 8px;
            }

            #restartBtn {
                margin-left: 0;
                width: 100%;
                max-width: 200px;
            }
        }

        @media (max-width: 480px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
                padding: 0 20px;
            }

            select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header-info">
        <span>Usuario: AdriPM-APM</span>
        <span>Fecha: 2025-04-24 19:37:26 UTC</span>
    </div>
    <div class="container">
        <h1>4 en Raya</h1>
        <div class="controls">
            <label for="modeSelect">Modo de Juego:</label>
            <select id="modeSelect">
                <option value="local">2 Jugadores</option>
                <option value="ai">Jugador vs IA</option>
            </select>
            <label for="aiLevel" id="aiLevelLabel" style="display:none;">Dificultad IA:</label>
            <select id="aiLevel" style="display:none;">
                <option value="easy">Fácil</option>
                <option value="medium">Medio</option>
                <option value="hard">Difícil</option>
            </select>
            <button id="restartBtn">Reiniciar Juego</button>
        </div>
        <div id="turnIndicator">Turno: <span id="currentPlayer">Rojo</span></div>
        <div id="gameContainer">
            <canvas id="gameBoard" width="700" height="600" aria-label="Tablero de 4 en raya"></canvas>
        </div>
        <div id="message"></div>
    </div>
    <script>
    // --- Configuración del juego ---
    const ROWS = 6;
    const COLS = 7;
    const BASE_CELL_SIZE = 100;

    const PLAYER1 = 1; // Rojo
    const PLAYER2 = 2; // Amarillo

    const COLORS = {
        0: "#21209c",
        1: "#ff595e", // Rojo
        2: "#ffe066", // Amarillo
        preview: "#a3c4f3"
    };

    let board = [];
    let currentPlayer = PLAYER1;
    let gameOver = false;
    let animating = false;
    let winner = null;
    let aiEnabled = false;
    let aiLevel = "easy";
    let cellSize = BASE_CELL_SIZE;

    const canvas = document.getElementById("gameBoard");
    const ctx = canvas.getContext("2d");
    const turnIndicator = document.getElementById("currentPlayer");
    const message = document.getElementById("message");
    const restartBtn = document.getElementById("restartBtn");
    const modeSelect = document.getElementById("modeSelect");
    const aiLevelSelect = document.getElementById("aiLevel");
    const aiLevelLabel = document.getElementById("aiLevelLabel");

    function resizeCanvas() {
        const container = document.getElementById("gameContainer");
        let w = container.offsetWidth;
        let h = window.innerHeight * 0.6;
        let maxW = Math.min(700, w);
        let maxH = Math.min(600, h);

        let aspectW = maxW;
        let aspectH = aspectW * (ROWS/COLS);
        if (aspectH > maxH) {
            aspectH = maxH;
            aspectW = aspectH * (COLS/ROWS);
        }
        
        canvas.width = aspectW;
        canvas.height = aspectH;
        cellSize = canvas.width / COLS;
        
        drawBoard();
    }

    function initGame() {
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        currentPlayer = PLAYER1;
        gameOver = false;
        winner = null;
        animating = false;
        updateTurnIndicator();
        message.textContent = "";
        drawBoard();
        if (aiEnabled && currentPlayer === PLAYER2) {
            setTimeout(aiMove, 400);
        }
    }

    function drawBoard(previewCol = null) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Fondo
        ctx.fillStyle = COLORS[0];
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Rejilla
        ctx.strokeStyle = "#1a1a3c";
        ctx.lineWidth = Math.max(2, cellSize * 0.02);
        
        for (let i = 1; i < COLS; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, canvas.height);
            ctx.stroke();
        }
        
        for (let i = 1; i < ROWS; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * cellSize);
            ctx.lineTo(canvas.width, i * cellSize);
            ctx.stroke();
        }

        // Agujeros y fichas
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                const xc = col * cellSize + cellSize / 2;
                const yc = row * cellSize + cellSize / 2;
                const radius = cellSize * 0.4;

                // Agujero
                ctx.beginPath();
                ctx.arc(xc, yc, radius, 0, 2 * Math.PI);
                ctx.fillStyle = "#f4f4f4";
                ctx.fill();

                // Ficha si existe
                if (board[row][col]) {
                    drawDisc(col, row, COLORS[board[row][col]]);
                }
            }
        }

        // Vista previa
        if (previewCol !== null && !gameOver && !animating) {
            const row = getAvailableRow(previewCol);
            if (row !== null) {
                drawDisc(previewCol, row, COLORS[currentPlayer], 0.3);
            }
        }
    }

    function drawDisc(col, row, color, alpha = 1) {
        const xc = col * cellSize + cellSize / 2;
        const yc = row * cellSize + cellSize / 2;
        const radius = cellSize * 0.35;

        ctx.save();
        ctx.globalAlpha = alpha;
        
        // Sombra
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.shadowBlur = Math.max(4, cellSize * 0.08);
        ctx.shadowOffsetY = 2;

        // Gradiente para efecto 3D
        const gradient = ctx.createRadialGradient(
            xc - radius * 0.3, yc - radius * 0.3, radius * 0.1,
            xc, yc, radius
        );
        gradient.addColorStop(0, '#fff');
        gradient.addColorStop(0.2, color);
        gradient.addColorStop(1, color);

        ctx.beginPath();
        ctx.arc(xc, yc, radius, 0, 2 * Math.PI);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.restore();
    }

    function enqueueMove(col, player, callback) {
        if (gameOver || animating || (aiEnabled && player === PLAYER2)) return;
        
        const row = getAvailableRow(col);
        if (row === null) return;
        
        animating = true;
        animateDrop(col, row, player, () => {
            board[row][col] = player;
            animating = false;
            
            if (checkWin(row, col, player)) {
                winner = player;
                gameOver = true;
                showMessage(`¡${getPlayerName(player)} gana!`);
            } else if (isBoardFull()) {
                gameOver = true;
                showMessage("¡Empate!");
            } else {
                switchPlayer();
                if (aiEnabled && currentPlayer === PLAYER2) {
                    setTimeout(aiMove, 350);
                }
            }
            updateTurnIndicator();
            drawBoard();
            if (callback) callback(row, col, player);
        });
    }

    function animateDrop(col, targetRow, player, callback) {
        let y = -cellSize / 2;
        const x = col * cellSize + cellSize / 2;
        const yEnd = targetRow * cellSize + cellSize / 2;
        let velocity = 0;
        const gravity = cellSize * 0.025;
        const bounce = 0.6;
        let bounces = 0;
        const maxBounces = 2;

        function frame() {
            drawBoard();
            
            // Dibujar ficha cayendo
            drawDisc(col, y/cellSize, COLORS[player]);

            if (y < yEnd) {
                velocity += gravity;
                y += velocity;
                
                // Si llegamos al final
                if (y > yEnd) {
                    if (bounces < maxBounces) {
                        y = yEnd;
                        velocity = -velocity * bounce;
                        bounces++;
                    } else {
                        y = yEnd;
                    }
                }
                requestAnimationFrame(frame);
            } else {
                if (callback) callback();
            }
        }
        frame();
    }

    canvas.addEventListener("mousemove", (e) => {
        if (gameOver || animating || (aiEnabled && currentPlayer === PLAYER2)) return;
        const col = getColFromEvent(e);
        drawBoard(col);
    });

    canvas.addEventListener("mouseleave", () => {
        if (!animating) drawBoard();
    });

    canvas.addEventListener("click", (e) => {
        if (gameOver || animating || (aiEnabled && currentPlayer === PLAYER2)) return;
        const col = getColFromEvent(e);
        if (getAvailableRow(col) !== null) {
            enqueueMove(col, currentPlayer);
        }
    });

    canvas.addEventListener("touchstart", (e) => {
        if (gameOver || animating || (aiEnabled && currentPlayer === PLAYER2)) return;
        e.preventDefault();
        const col = getColFromEvent(e);
        if (getAvailableRow(col) !== null) {
            enqueueMove(col, currentPlayer);
        }
    });

    function aiMove() {
        if (gameOver || animating) return;
        let col = getAIMove();
        if (col !== null) {
            enqueueMove(col, PLAYER2);
        }
    }

    function getAIMove() {
        if (aiLevel === "easy") {
            const valid = getValidColumns();
            return valid[Math.floor(Math.random() * valid.length)];
        }
        
        if (aiLevel === "medium") {
            // Primero intenta ganar
            let winCol = findWinningMove(PLAYER2);
            if (winCol !== null) return winCol;
            
            // Luego intenta bloquear
            let blockCol = findWinningMove(PLAYER1);
            if (blockCol !== null) return blockCol;
            
            // Si no, movimiento aleatorio
            const valid = getValidColumns();
            return valid[Math.floor(Math.random() * valid.length)];
        }
        
        if (aiLevel === "hard") {
            return minimaxRoot(4, PLAYER2);
        }
        
        // Fallback a movimiento aleatorio
        const valid = getValidColumns();
        return valid[Math.floor(Math.random() * valid.length)];
    }

    // ... [Resto del código minimax y funciones auxiliares permanecen igual]
    function getAvailableRow(col) {
        for (let row = ROWS - 1; row >= 0; row--) {
            if (board[row][col] === 0) {
                return row;
            }
        }
        return null;
    }

    function getColFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        let x;
        if (e.touches && e.touches[0]) {
            x = e.touches[0].clientX - rect.left;
        } else {
            x = e.clientX - rect.left;
        }
        return Math.floor(x / cellSize);
    }

    function switchPlayer() {
        currentPlayer = currentPlayer === PLAYER1 ? PLAYER2 : PLAYER1;
    }

    function getPlayerName(player) {
        if (aiEnabled && player === PLAYER2) return "IA";
        return player === PLAYER1 ? "Rojo" : "Amarillo";
    }

    function updateTurnIndicator() {
        turnIndicator.textContent = getPlayerName(currentPlayer);
        turnIndicator.style.color = COLORS[currentPlayer];
    }

    function showMessage(msg) {
        message.textContent = msg;
    }

    function checkWin(row, col, player) {
        // Check horizontal
        let count = 0;
        for (let c = Math.max(0, col - 3); c <= Math.min(COLS - 1, col + 3); c++) {
            if (board[row][c] === player) {
                count++;
                if (count >= 4) return true;
            } else {
                count = 0;
            }
        }

        // Check vertical
        count = 0;
        for (let r = Math.max(0, row - 3); r <= Math.min(ROWS - 1, row + 3); r++) {
            if (board[r][col] === player) {
                count++;
                if (count >= 4) return true;
            } else {
                count = 0;
            }
        }

        // Check diagonal (top-left to bottom-right)
        count = 0;
        let startRow = row - Math.min(row, col);
        let startCol = col - Math.min(row, col);
        for (let i = 0; startRow + i < ROWS && startCol + i < COLS; i++) {
            if (board[startRow + i][startCol + i] === player) {
                count++;
                if (count >= 4) return true;
            } else {
                count = 0;
            }
        }

        // Check diagonal (top-right to bottom-left)
        count = 0;
        startRow = row - Math.min(row, COLS - 1 - col);
        startCol = col + Math.min(row, COLS - 1 - col);
        for (let i = 0; startRow + i < ROWS && startCol - i >= 0; i++) {
            if (board[startRow + i][startCol - i] === player) {
                count++;
                if (count >= 4) return true;
            } else {
                count = 0;
            }
        }

        return false;
    }

    function isBoardFull() {
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                if (board[row][col] === 0) {
                    return false;
                }
            }
        }
        return true;
    }

    function getValidColumns() {
        let validColumns = [];
        for (let col = 0; col < COLS; col++) {
            if (getAvailableRow(col) !== null) {
                validColumns.push(col);
            }
        }
        return validColumns;
    }

    function findWinningMove(player) {
        for (let col = 0; col < COLS; col++) {
            let row = getAvailableRow(col);
            if (row !== null) {
                board[row][col] = player;
                if (checkWin(row, col, player)) {
                    board[row][col] = 0; // Reset the board
                    return col;
                }
                board[row][col] = 0; // Reset the board
            }
        }
        return null;
    }
    function evaluateWindow(window, player) {
        let score = 0;
        let opponent = (player === PLAYER1) ? PLAYER2 : PLAYER1;

        let playerCount = window.filter(x => x === player).length;
        let emptyCount = window.filter(x => x === 0).length;
        let opponentCount = window.filter(x => x === opponent).length;

        if (playerCount === 4) {
            score += 100;
        } else if (playerCount === 3 && emptyCount === 1) {
            score += 5;
        } else if (playerCount === 2 && emptyCount === 2) {
            score += 2;
        }

        if (opponentCount === 3 && emptyCount === 1) {
            score -= 4;
        }

        return score;
    }

    function scorePosition(board, player) {
        let score = 0;

        // Score center column
        let centerArray = [];
        for (let i = 0; i < ROWS; i++) {
            centerArray.push(board[i][COLS / 2]);
        }
        let centerCount = centerArray.filter(x => x === player).length;
        score += centerCount * 3;

        // Score Horizontal
        for (let r = 0; r < ROWS; r++) {
            let rowArray = [];
            for (let i = 0; i < COLS; i++) {
                rowArray.push(board[r][i]);
            }
            for (let c = 0; c < COLS - 3; c++) {
                let window = rowArray.slice(c, c + 4);
                score += evaluateWindow(window, player);
            }
        }

        // Score Vertical
        for (let c = 0; c < COLS; c++) {
            let colArray = [];
            for (let i = 0; i < ROWS; i++) {
                colArray.push(board[i][c]);
            }
            for (let r = 0; r < ROWS - 3; r++) {
                let window = colArray.slice(r, r + 4);
                score += evaluateWindow(window, player);
            }
        }

        // Score positive sloped diagonals
        for (let r = 0; r < ROWS - 3; r++) {
       
